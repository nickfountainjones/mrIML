#' mrFlashlight: Wrapper to run multi-response model agnostic interpretable machine learning analyses. 
#'
#' @param yhats A \code{list} generated by \code{mrIMLpredicts}.
#' @param Y A \code{data.frame} containing the response variable data set (species, OTUs, SNPs, etc.).
#' @param X A \code{data.frame} containing the feature data set.
#' @param X1 A \code{data.frame} of additional predictors (optional).
#' @param response \code{character} indicating the type of response: 'single' selects one response, 'multi' selects all responses.
#' @param index \code{numeric} used when \code{response} is 'single' to select which response to create a flashlight object for. The order is the same as in \code{Y}.
#' @param predict_function \code{function} specifying a user-defined prediction function (optional).
#' @param mode \code{character} indicating the type of model: 'classification' or 'regression'.
#'
#' @details This function enables users to utilize interpretable machine learning methods to understand their multi-response and single-response models.
#'
#' @examples 
#' library(tidymodels)
#' library(flashlight)
#' 
#' data <- MRFcov::Bird.parasites
#' Y <- data %>%
#'   select(-scale.prop.zos) %>%
#'   select(order(everything()))
#' X <- data %>%
#'   select(scale.prop.zos)
#' 
#' model_rf <- rand_forest(
#'   trees = 100, # 100 trees are set for brevity. Aim to start with 1000
#'   mode = "classification",
#'   mtry = tune(),
#'   min_n = tune()
#' ) %>%
#'   set_engine("randomForest")
#'
#' mrIML_rf <- mrIMLpredicts(
#'   X = X,
#'   Y = Y,
#'   X1 = Y,
#'   Model = model_rf,
#'   prop = 0.7,
#'   k = 5
#' )
#' 
#' fl <- mrFlashlight(
#'   mrIML_rf,
#'   response = "multi",
#'   index = 1
#' )
#' 
#' # Performance comparison
#' fl %>%
#'   light_performance(
#'     metrics = list(`ROC AUC` = MetricsWeighted::AUC)
#'   ) %>%
#'   plot() +
#'   ylim(0, 1)
#'   
#' # Partial dependence curves
#' fl %>%
#'   light_profile(data = cbind(X, Y), "scale.prop.zos") %>%
#'   plot()
#'   
#' # Two-way partial dependence
#' fl %>%
#'   light_profile2d(c("scale.prop.zos","Plas")) %>%
#'   plot()
#' @export


mrFlashlight <- function(mrIMLobj,
                         response = "multi",
                         index = 1,
                         predict_function = NULL) {
  
  # Unpack mrIML object
  yhats <- mrIMLobj$Fits
  Model <- mrIMLobj$Model
  Y <- mrIMLobj$Data$Y
  X <- mrIMLobj$Data$X
  X1 <- mrIMLobj$Data$X1
  mode <- mrIMLobj$Model$mode
  
  # Set up flashlight functions for mode
  flashlight_ops <- mrIML_flashlight_setup(
    mode,
    predict_function
  )
  
  # Run flashlight on models...
  if (response == "single") {
    mfl <- flashlight::flashlight(
      model = yhats[[index]]$last_mod_fit,
      label = colnames(Y)[index],
      data = cbind(Y[index], X),
      y = colnames(Y)[index],
      predict_function = flashlight_ops$pred_fun,
      metrics = flashlight_ops$metrics
    )
  } else if (response == "multi") {
    fl_list <- lapply(
      seq_along(yhats),
      function(i) {
        flashlight::flashlight(
          model = yhats[[i]]$last_mod_fit,
          label = colnames(Y)[i],
          y = colnames(Y)[i],
          x = colnames(yhats[[i]]$data)[-1]
        )
      }
    )
    mfl <- flashlight::multiflashlight(
      fl_list,
      data = cbind(Y, X),
      predict_function = flashlight_ops$pred_fun,
      metrics = flashlight_ops$metrics
    )
  } else {
    stop(
      "Response type must be either \"single\" or \"multi\".",
      call. = FALSE
    )
  }
  
  mfl
}

mrIML_flashlight_setup <- function(mode, predict_function = NULL) {
  if (mode == "classification") {
    pred_fun <- function(m, dat) {
      if (!("workflow" %in% class(m))) {
        m <- hardhat::extract_workflow(m)
      }
      pred <- m %>%
        predict(
          new_data = dat,
          type = "prob"
        )
      pred %>%
        dplyr::pull(".pred_1")
    }
    metrics <- list(
      logloss = MetricsWeighted::logLoss,
      `ROC AUC` = MetricsWeighted::AUC,
      `% Dev Red` = MetricsWeighted::r_squared_bernoulli
    )
  } else if (mode == "regression") {
    pred_fun <- function(m, dat) {
      pred <- m %>%
        hardhat::extract_workflow() %>%
        predict(
          new_data = dat
        )
      pred %>%
        dplyr::pull(".pred")
    }
    metrics <- list(
      rmse = MetricsWeighted::rmse,
      `R-squared` = MetricsWeighted::r_squared
    )
  } else {
    stop(
      paste0(
        "mrFlashlight() is currently only available for mode \"classification\"  
        or \"regression\"."
      )
    )
  }
  # Override pred_fun() if user has supplied one
  if (!is.null(predict_function)) pred_fun <- predict_function
  
  list(
    metrics = metrics,
    pred_fun = pred_fun
  )
}
